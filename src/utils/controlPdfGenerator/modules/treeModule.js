// src/utils/controlPdfGenerator/modules/treeModule.js - Tree-struktur modul f√∂r PDF

import { getRemarksForNode, countRemarksInSubtree } from '../utils/treeUtils';

/**
 * Renderar tr√§d-strukturen med perfekt linje-alignment och anm√§rkningar
 * @param {Object} pdfState - PDF state objekt
 * @param {Array} tree - Hierarkisk tr√§d-struktur
 * @param {Array} remarks - Array av alla anm√§rkningar
 * @returns {Promise<number>} - Ny Y-position
 */
export const renderTreeStructure = async (pdfState, tree, remarks, progressState = null, imageCache = null) => {
  const { doc, pageWidth, pageHeight, margins } = pdfState;
  let yPos = pdfState.yPosition;
  
  console.log('Rendering clean tree structure');
  
  // CORPORATE DESIGN SYSTEM
  const design = {
    // Clean Typography
    fonts: {
      sectionHeader: { size: 12, weight: 'bold' },
      locationHeader: { size: 12, weight: 'bold' },  // St√∂rre
      areaName: { size: 10, weight: 'bold' },        // Tjockare
      remarkTitle: { size: 8, weight: 'bold' },
      remarkText: { size: 8, weight: 'normal' }
    },
    
    // Corporate Color Palette
    colors: {
      primary: [13, 71, 161],       // Corporate blue
      secondary: [33, 33, 33],      // Dark charcoal
      accent: [255, 152, 0],        // Warning orange
      success: [46, 125, 50],       // Success green
      error: [198, 40, 40],         // Error red
      lightGray: [245, 245, 245],   // Light background
      mediumGray: [158, 158, 158],  // Medium text
      border: [224, 224, 224]       // Borders
    },
    
    // Compact Layout System
    spacing: {
      sectionGap: 8,           // Between main locations (reduced from 15)
      subsectionGap: 4,        // Between areas in location (reduced from 8)
      remarkSection: 6,        // Before remark sections (reduced from 10)
      remarkGap: 4,            // Between individual remarks (reduced from 8)
      indent: 12,              // Standard indentation (reduced from 15)
      cardPadding: 4           // Internal card padding (reduced from 8)
    }
  };
  
  // Ingen header beh√∂vs, b√∂rja direkt med f√∂rsta noden
  yPos += 5;
  
  // Rendera varje huvudnod (adress/byggnad)
  for (let i = 0; i < tree.length; i++) {
    const rootNode = tree[i];
    
    if (i > 0) {
      yPos += design.spacing.sectionGap;
    }
    
    // Kontrollera sidbrytning
    const estimatedHeight = estimateNodeHeight(rootNode, remarks, design);
    if (yPos + estimatedHeight > pageHeight - margins.bottom - 50) {
      doc.addPage();
      yPos = margins.top + 20;
    }
    
    yPos = await renderCorporateLocationSection(pdfState, rootNode, remarks, yPos, design, imageCache);
  }
  
  return yPos + 20;
};

/**
 * Renderar en corporate location section med professionellt utseende
 */
const renderCorporateLocationSection = async (pdfState, locationNode, remarks, yPos, design, imageCache = null) => {
  const { doc, pageWidth, margins } = pdfState;
  
  // CLEAN LOCATION HEADER med svart cirkel - st√∂rre och tjockare
  doc.setTextColor(...design.colors.secondary);
  doc.setFont('helvetica', design.fonts.locationHeader.weight);
  doc.setFontSize(design.fonts.locationHeader.size);
  
  // Rita svart cirkel f√∂re namnet - centrerad med texten
  doc.setFillColor(0, 0, 0); // Svart
  doc.circle(margins.left + 3, yPos - 1.5, 2, 'F'); // Cirkel med radie 2px, centrerad
  
  doc.text(locationNode.name, margins.left + 10, yPos); // Offset texten f√∂r cirkeln
  
  yPos += 12; // Reduced from 18
  
  // Rendera omr√•den under denna location
  if (locationNode.children && locationNode.children.length > 0) {
    for (let i = 0; i < locationNode.children.length; i++) {
      const areaNode = locationNode.children[i];
      const areaRemarks = getRemarksForNode(areaNode.id, remarks);
      
      // Bara visa omr√•de om det har anm√§rkningar eller barn med anm√§rkningar
      if (areaRemarks.length > 0 || hasRemarksInChildren(areaNode, remarks)) {
        yPos = await renderCorporateAreaSection(pdfState, areaNode, remarks, yPos, design, 1, imageCache);
        
        if (i < locationNode.children.length - 1) {
          yPos += design.spacing.subsectionGap;
        }
      }
    }
  }
  
  // Om location-noden sj√§lv har anm√§rkningar
  const locationRemarks = getRemarksForNode(locationNode.id, remarks);
  if (locationRemarks.length > 0) {
    yPos += design.spacing.remarkSection;
    yPos = await renderCorporateRemarkSection(pdfState, locationRemarks, yPos, design, locationNode.name, 0, imageCache);
  }
  
  return yPos;
};

/**
 * Renderar ett omr√•de (som "K√§llare", "Elcentral") med corporate styling
 */
const renderCorporateAreaSection = async (pdfState, areaNode, remarks, yPos, design, level = 1, imageCache = null) => {
  const { doc, pageWidth, pageHeight, margins } = pdfState;
  const areaRemarks = getRemarksForNode(areaNode.id, remarks);
  
  // Ber√§kna total h√∂jd f√∂r denna area och dess anm√§rkningar (inkl. bilder)
  if (areaRemarks.length > 0) {
    const estimatedAreaHeight = estimateAreaWithRemarksHeight(areaNode, areaRemarks, design);
    
    // Om det inte finns plats, g√∂r sidbrytning INNAN vi b√∂rjar rendera
    if (yPos + estimatedAreaHeight > pageHeight - margins.bottom - 20) {
      doc.addPage();
      yPos = margins.top + 20;
    }
  }
  
  // SIMPLE AREA HEADER med streck - tjockare text f√∂r tydlighet
  const indentX = margins.left + (level * 12); // 12px indrag per niv√• (uppdaterat fr√•n design)
  
  doc.setTextColor(...design.colors.secondary);
  doc.setFont('helvetica', design.fonts.areaName.weight);
  doc.setFontSize(design.fonts.areaName.size);
  
  // Rita streck f√∂re namnet
  doc.text('‚Äì', indentX, yPos); // Em-dash symbol
  
  doc.text(areaNode.name, indentX + 8, yPos); // Offset texten f√∂r strecket
  
  yPos += 10; // Reduced from 14
  
  // Rendera anm√§rkningar f√∂r detta omr√•de med korrekt indentering
  if (areaRemarks.length > 0) {
    yPos = await renderCorporateRemarkSection(pdfState, areaRemarks, yPos, design, areaNode.name, level, imageCache);
  }
  
  // Rendera barn-noder rekursivt med √∂kad indentering
  if (areaNode.children && areaNode.children.length > 0) {
    for (const child of areaNode.children) {
      const childRemarks = getRemarksForNode(child.id, remarks);
      if (childRemarks.length > 0 || hasRemarksInChildren(child, remarks)) {
        yPos = await renderCorporateAreaSection(pdfState, child, remarks, yPos, design, level + 1, imageCache);
      }
    }
  }
  
  return yPos;
};

/**
 * Kontrollerar om en nod har anm√§rkningar i sina barn
 */
const hasRemarksInChildren = (node, remarks) => {
  if (!node.children || node.children.length === 0) return false;
  
  for (const child of node.children) {
    const childRemarks = getRemarksForNode(child.id, remarks);
    if (childRemarks.length > 0) return true;
    if (hasRemarksInChildren(child, remarks)) return true;
  }
  
  return false;
};

/**
 * Renderar corporate-style remark section med bilder
 */
const renderCorporateRemarkSection = async (pdfState, remarks, yPos, design, areaName, level = 1, imageCache = null) => {
  const { doc, pageWidth, pageHeight, margins } = pdfState;
  const remarkIndent = margins.left + (level * 12) + 18; // Samma indrag som areas + 18px f√∂r dash och text
  
  for (let i = 0; i < remarks.length; i++) {
    const remark = remarks[i];
    
    // SIMPLE REMARK - bara clean text
    const priorityColor = getCorporatePriorityColor(remark.priority);
    
    // Priority och text p√• samma rad (om prioritet finns)
    let textIndent = remarkIndent;
    if (remark.priority) {
      doc.setTextColor(...priorityColor);
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(9);
      doc.text(`[${remark.priority}]`, remarkIndent, yPos);
      textIndent += 15; // Offset f√∂r prioritet-text
    }
    
    // Remark text
    const maxTextWidth = pageWidth - textIndent - margins.right - 20;
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(9);
    const textLines = doc.splitTextToSize(remark.text, maxTextWidth);
    
    doc.setTextColor(...design.colors.secondary);
    doc.text(textLines, textIndent, yPos);
    
    yPos += (textLines.length * 3.5) + 1; // Reduced line spacing
    
    // Images if available - show actual images!
    const hasImages = remark.images && remark.images.length > 0;
    if (hasImages) {
      yPos += 3;
      yPos = await renderActualImages(pdfState, remark.images, yPos, remarkIndent + 20, design, imageCache);
    }
    
    yPos += design.spacing.remarkGap;
  }
  
  return yPos;
};

/**
 * Renderar riktiga bilder i PDF
 */
const renderActualImages = async (pdfState, images, yPos, xPos, design, imageCache = null) => {
  const { doc, pageWidth, pageHeight, margins } = pdfState;
  
  if (!images || images.length === 0) return yPos;
  
  // Ingen text header - bara visa bilderna direkt
  // yPos += 5; // Mindre spacing
  
  // Rendera varje bild - anv√§nd cachade bilder f√∂r snabbhet
  for (let i = 0; i < Math.min(images.length, 3); i++) { // Max 3 bilder per anm√§rkning
    const image = images[i];
    
    const imageUrl = image.url || image.downloadURL;
    if (!imageUrl) continue;
    
    // H√§mta bild fr√•n cache med f√∂rb√§ttrad nyckelhantering
    let cachedImage = null;
    if (imageCache) {
      // F√∂rs√∂k hitta bilden i cache med olika nycklar
      for (let [key, value] of imageCache.entries()) {
        if (key.includes(imageUrl) || key === imageUrl) {
          cachedImage = value;
          console.log('üéØ Found cached image for:', imageUrl, 'with key:', key);
          break;
        }
      }
    }
    
    if (cachedImage) {
      try {
        // Ber√§kna bildstorlek (max 80x60)
        const maxWidth = 80;
        const maxHeight = 60;
        
        const aspectRatio = cachedImage.width / cachedImage.height;
        let imgWidth = maxWidth;
        let imgHeight = maxWidth / aspectRatio;
        
        if (imgHeight > maxHeight) {
          imgHeight = maxHeight;
          imgWidth = maxHeight * aspectRatio;
        }
        
        // Rita bilden fr√•n cache
        doc.addImage(cachedImage.data, 'JPEG', xPos, yPos, imgWidth, imgHeight);
        yPos += imgHeight + 3; // Reduced spacing after images
        
      } catch (error) {
        console.warn('Could not render cached image:', error);
        // Fallback
        doc.setFillColor(...design.colors.lightGray);
        doc.rect(xPos, yPos, 60, 40, 'F');
        doc.setTextColor(...design.colors.mediumGray);
        doc.setFontSize(8);
        doc.text('Bild ej tillg√§nglig', xPos + 5, yPos + 22);
        yPos += 45;
      }
    } else {
      // Fallback om ingen cache finns
      console.warn('Image not found in cache:', imageUrl);
      doc.setFillColor(...design.colors.lightGray);
      doc.rect(xPos, yPos, 60, 40, 'F');
      doc.setTextColor(...design.colors.mediumGray);
      doc.setFontSize(8);
      doc.text('Bild ej tillg√§nglig', xPos + 5, yPos + 22);
      yPos += 45;
    }
  }
  
  // Om fler √§n 3 bilder
  if (images.length > 3) {
    doc.setTextColor(...design.colors.mediumGray);
    doc.setFontSize(7);
    doc.text(`... och ${images.length - 3} bilder till`, xPos, yPos);
    yPos += 10;
  }
  
  return yPos + 3; // Reduced final spacing
};

// Gamla loadImageFromUrl funktionen har ersatts av imageOptimizer f√∂r b√§ttre prestanda

/**
 * H√§mtar corporate f√§rg f√∂r prioritet
 */
const getCorporatePriorityColor = (priority) => {
  switch (priority) {
    case 'A': return [198, 40, 40];    // Error red
    case 'B': return [255, 152, 0];    // Warning orange  
    case 'C': return [46, 125, 50];    // Success green
    case '':
    case null:
    case undefined:
    default: return [158, 158, 158];   // Medium gray
  }
};

/**
 * H√§mtar kompakt prioritetstext
 */
const getPriorityText = (priority) => {
  switch (priority) {
    case 'A': return 'KRITISK';
    case 'B': return 'VARNING';
    case 'C': return 'NOTERING';
    default: return 'OK√ÑND';
  }
};

/**
 * Estimerar h√∂jden f√∂r en area med dess anm√§rkningar och bilder
 */
const estimateAreaWithRemarksHeight = (areaNode, areaRemarks, design) => {
  let totalHeight = 10; // Area header h√∂jd
  
  // Ber√§kna h√∂jd f√∂r varje anm√§rkning
  areaRemarks.forEach(remark => {
    // Text h√∂jd (grov uppskattning)
    const textLines = Math.ceil(remark.text.length / 80); // ~80 tecken per rad
    totalHeight += (textLines * 3.5) + 1; // Line spacing
    
    // Bild h√∂jd om bilder finns
    if (remark.images && remark.images.length > 0) {
      const imageCount = Math.min(remark.images.length, 3); // Max 3 bilder visas
      totalHeight += (imageCount * 60) + (imageCount * 3); // 60px per bild + 3px spacing
      totalHeight += 3; // Extra spacing efter bilder
    }
    
    totalHeight += design.spacing.remarkGap; // Spacing mellan anm√§rkningar
  });
  
  return totalHeight + 20; // Extra marginal
};

/**
 * Estimerar h√∂jden som en nod kommer att ta
 */
const estimateNodeHeight = (node, remarks, design) => {
  const nodeRemarks = getRemarksForNode(node.id, remarks);
  let height = 25; // Bas-h√∂jd f√∂r nod
  
  // L√§gg till h√∂jd f√∂r anm√§rkningar (mer exakt ber√§kning)
  height += nodeRemarks.length * 25; // Premium anm√§rknings-boxar tar mer plats
  
  // L√§gg till h√∂jd f√∂r barn rekursivt
  if (node.children) {
    node.children.forEach(child => {
      height += estimateNodeHeight(child, remarks, design);
    });
  }
  
  return height;
};

/**
 * F√• f√§rg f√∂r prioritet
 */
const getPriorityColor = (priority) => {
  switch (priority) {
    case 'A': return [220, 38, 38];   // R√∂d
    case 'B': return [245, 158, 11];  // Orange
    case 'C': return [16, 185, 129];  // Gr√∂n
    default: return [107, 114, 128];  // Gr√•
  }
};